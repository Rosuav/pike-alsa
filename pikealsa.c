/* Generated from "pikealsa.cmod" by precompile.pike
 *
 * Do NOT edit this file.
 */

#undef PRECOMPILE_API_VERSION
#define PRECOMPILE_API_VERSION 4



#undef cmod___CMOD__
#define cmod___CMOD__ 1
/*Code created by imitating aplaymidi, though no actual code copied in */
#line 2 "pikealsa.cmod"
#include "global.h"
#include "interpret.h"
#include "module.h"
#include "array.h"
#include <alsa/asoundlib.h>



#ifndef TYPEOF
/* Compat with older Pikes. */
#define TYPEOF(SVAL)	((SVAL).type)
#define SUBTYPEOF(SVAL)	((SVAL).subtype)
#define SET_SVAL_TYPE(SVAL, TYPE)	(TYPEOF(SVAL) = TYPE)
#define SET_SVAL_SUBTYPE(SVAL, TYPE)	(SUBTYPEOF(SVAL) = TYPE)
#define SET_SVAL(SVAL, TYPE, SUBTYPE, FIELD, EXPR) do {	\
    /* Set the type afterwards to avoid a clobbered	\
     * svalue in case EXPR throws. */			\
    (SVAL).u.FIELD = (EXPR);				\
    SET_SVAL_TYPE((SVAL), (TYPE));			\
    SET_SVAL_SUBTYPE((SVAL), (SUBTYPE));		\
  } while(0)
#endif /* !TYPEOF */


#ifndef DEFAULT_CMOD_STORAGE
#define DEFAULT_CMOD_STORAGE
#endif

#undef class_ALSA_defined
#define class_ALSA_defined
DEFAULT_CMOD_STORAGE struct program *ALSA_program=NULL;
static int ALSA_program_fun_num=-1;

#undef var_seq_ALSA_defined
#define var_seq_ALSA_defined

#undef var_port_ALSA_defined
#define var_port_ALSA_defined

#undef var_queue_ALSA_defined
#define var_queue_ALSA_defined

#undef THIS
#define THIS ((struct ALSA_struct *)(Pike_interpreter.frame_pointer->current_storage))

#undef THIS_ALSA
#define THIS_ALSA ((struct ALSA_struct *)(Pike_interpreter.frame_pointer->current_storage))

#undef OBJ2_ALSA
#define OBJ2_ALSA(o) ((struct ALSA_struct *)(o->storage+ALSA_storage_offset))

#undef GET_ALSA_STORAGE
#define GET_ALSA_STORAGE(o) ((struct ALSA_struct *)(o->storage+ALSA_storage_offset)
static ptrdiff_t ALSA_storage_offset;
struct ALSA_struct {

#ifdef var_seq_ALSA_defined
#line 12 "pikealsa.cmod"
snd_seq_t *seq;
#endif /* var_seq_ALSA_defined */

#ifdef var_port_ALSA_defined
#line 13 "pikealsa.cmod"
snd_seq_addr_t port;
#endif /* var_port_ALSA_defined */

#ifdef var_queue_ALSA_defined
#line 14 "pikealsa.cmod"
int queue;
#endif /* var_queue_ALSA_defined */
};
#ifdef PIKE_DEBUG
/* Ensure the struct is used in a variable declaration, or else gdb might not see it. */
static struct ALSA_struct *ALSA_gdb_dummy_ptr;
#endif

#undef internal_init_ALSA_defined
#define internal_init_ALSA_defined

#undef ALSA_event_handler_defined
#define ALSA_event_handler_defined
static void init_ALSA_struct(void)
#line 16 "pikealsa.cmod"
{
		snd_seq_open(&THIS->seq,"default",SND_SEQ_OPEN_DUPLEX,0);
		snd_seq_set_client_name(THIS->seq,"pikealsa");
	}
	
#undef ALSA_gc_live_obj
#define ALSA_gc_live_obj

#undef internal_exit_ALSA_defined
#define internal_exit_ALSA_defined

#undef ALSA_event_handler_defined
#define ALSA_event_handler_defined
static void exit_ALSA_struct(void)
#line 21 "pikealsa.cmod"
{
		snd_seq_close(THIS->seq);
	}
	#define f_ALSA_list_ports_defined
DEFAULT_CMOD_STORAGE ptrdiff_t f_ALSA_list_ports_fun_num = 0;
DEFAULT_CMOD_STORAGE void f_ALSA_list_ports(INT32 args) {
#line 24 "pikealsa.cmod"
if(args != 0) wrong_number_of_args_error("list_ports",args,0);
{
		int nports=0;
		snd_seq_client_info_t *cinfo;
		snd_seq_port_info_t *pinfo;
		pop_n_elems(args);
		snd_seq_client_info_alloca(&cinfo);
		snd_seq_port_info_alloca(&pinfo);
		snd_seq_client_info_set_client(cinfo,-1);
		while (snd_seq_query_next_client(THIS->seq,cinfo)>=0)
		{
			int client=snd_seq_client_info_get_client(cinfo);
			snd_seq_port_info_set_client(pinfo,client);
			snd_seq_port_info_set_port(pinfo,-1);
			while (snd_seq_query_next_port(THIS->seq,pinfo)>=0)
			{
				const unsigned need=SND_SEQ_PORT_CAP_WRITE|SND_SEQ_PORT_CAP_SUBS_WRITE;
				if ((snd_seq_port_info_get_capability(pinfo)&need)!=need) continue;
				push_int(snd_seq_port_info_get_client(pinfo));
				push_int(snd_seq_port_info_get_port(pinfo));
				push_string(make_shared_string(snd_seq_client_info_get_name(cinfo)));
				push_string(make_shared_string(snd_seq_port_info_get_name(pinfo)));
				push_array(aggregate_array(4));
				++nports;
			}
		}
		push_array(aggregate_array(nports));
	}
	}
#define f_ALSA_set_port_defined
DEFAULT_CMOD_STORAGE ptrdiff_t f_ALSA_set_port_fun_num = 0;
DEFAULT_CMOD_STORAGE void f_ALSA_set_port(INT32 args) {
#line 52 "pikealsa.cmod"
INT_TYPE client;
#line 52 "pikealsa.cmod"
INT_TYPE port;
#line 52 "pikealsa.cmod"
if(args != 2) wrong_number_of_args_error("set_port",args,2);
#line 52 "pikealsa.cmod"
if(TYPEOF(Pike_sp[0-2]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("set_port",1,"int");
#line 52 "pikealsa.cmod"
client=Pike_sp[0-2].u.integer;
#line 52 "pikealsa.cmod"
if(TYPEOF(Pike_sp[1-2]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("set_port",2,"int");
#line 52 "pikealsa.cmod"
port=Pike_sp[1-2].u.integer;
#line 55 "pikealsa.cmod"
{
		int err;
		snd_seq_port_info_t *pinfo;
		THIS->port.client=client; THIS->port.port=port;
		snd_seq_port_info_alloca(&pinfo);
		snd_seq_port_info_set_port(pinfo,0);
		snd_seq_port_info_set_port_specified(pinfo,1);
		snd_seq_port_info_set_name(pinfo,"pikealsa");
		snd_seq_port_info_set_capability(pinfo,0); /*the original said / * sic * / here */
		snd_seq_port_info_set_type(pinfo,SND_SEQ_PORT_TYPE_MIDI_GENERIC|SND_SEQ_PORT_TYPE_APPLICATION);
		err=snd_seq_create_port(THIS->seq,pinfo); if (err<0) do { INT_TYPE ret_=((err)); pop_n_elems(2); push_int(ret_); return; }while(0);
#line 66 "pikealsa.cmod"
THIS->queue=snd_seq_alloc_named_queue(THIS->seq,"pikealsa");
		err=snd_seq_connect_to(THIS->seq,0,THIS->port.client,THIS->port.port); if (err<0) do { INT_TYPE ret_=((err)); pop_n_elems(2); push_int(ret_); return; }while(0);
#line 68 "pikealsa.cmod"
snd_seq_start_queue(THIS->seq,THIS->queue,0);
		do { INT_TYPE ret_=((err)); pop_n_elems(2); push_int(ret_); return; }while(0);
#line 70 "pikealsa.cmod"
}
	}
#define f_ALSA_get_port_defined
DEFAULT_CMOD_STORAGE ptrdiff_t f_ALSA_get_port_fun_num = 0;
DEFAULT_CMOD_STORAGE void f_ALSA_get_port(INT32 args) {
#line 71 "pikealsa.cmod"
if(args != 0) wrong_number_of_args_error("get_port",args,0);
{
		push_int(THIS->port.client);
		push_int(THIS->port.port);
		push_array(aggregate_array(2));
	}
	}
#line 77 "pikealsa.cmod"
void msg(int type,int channel,int d1,int d2)
	{
		snd_seq_event_t ev;
		snd_seq_ev_clear(&ev);
		ev.queue=THIS->queue;
		ev.source.port=0;
		ev.flags=SND_SEQ_TIME_STAMP_TICK;
		ev.type=type;
		ev.time.tick=0;
		ev.dest=THIS->port;
		snd_seq_ev_set_fixed(&ev);
		ev.data.note.channel=channel; /*Assume that this is in the same place for everything and violate a rule of unions. */
		if (type==SND_SEQ_EVENT_NOTEON || type==SND_SEQ_EVENT_NOTEOFF || type==SND_SEQ_EVENT_KEYPRESS)
		{
			ev.data.note.note=d1;
			ev.data.note.velocity=d2;
		}
		else /*if (type==SND_SEQ_EVENT_PGMCHANGE || type==SND_SEQ_EVENT_CHANPRESS || type==SND_SEQ_EVENT_PITCHBEND || type==SND_SEQ_EVENT_CONTROLLER) */
		{
			ev.data.control.param=d1;
			ev.data.control.value=d2;
		}
		snd_seq_event_output(THIS->seq,&ev);
		snd_seq_drain_output(THIS->seq);
	}
	#define f_ALSA_note_on_defined
DEFAULT_CMOD_STORAGE ptrdiff_t f_ALSA_note_on_fun_num = 0;
DEFAULT_CMOD_STORAGE void f_ALSA_note_on(INT32 args) {
#line 102 "pikealsa.cmod"
INT_TYPE channel;
#line 102 "pikealsa.cmod"
INT_TYPE note;
#line 102 "pikealsa.cmod"
INT_TYPE velocity;
#line 102 "pikealsa.cmod"
if(args != 3) wrong_number_of_args_error("note_on",args,3);
#line 102 "pikealsa.cmod"
if(TYPEOF(Pike_sp[0-3]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("note_on",1,"int");
#line 102 "pikealsa.cmod"
channel=Pike_sp[0-3].u.integer;
#line 102 "pikealsa.cmod"
if(TYPEOF(Pike_sp[1-3]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("note_on",2,"int");
#line 102 "pikealsa.cmod"
note=Pike_sp[1-3].u.integer;
#line 102 "pikealsa.cmod"
if(TYPEOF(Pike_sp[2-3]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("note_on",3,"int");
#line 102 "pikealsa.cmod"
velocity=Pike_sp[2-3].u.integer;
#line 102 "pikealsa.cmod"
{msg(SND_SEQ_EVENT_NOTEON,channel,note,velocity); pop_n_elems(args);}
	}
#define f_ALSA_note_off_defined
DEFAULT_CMOD_STORAGE ptrdiff_t f_ALSA_note_off_fun_num = 0;
DEFAULT_CMOD_STORAGE void f_ALSA_note_off(INT32 args) {
#line 103 "pikealsa.cmod"
INT_TYPE channel;
#line 103 "pikealsa.cmod"
INT_TYPE note;
#line 103 "pikealsa.cmod"
INT_TYPE velocity;
#line 103 "pikealsa.cmod"
if(args != 3) wrong_number_of_args_error("note_off",args,3);
#line 103 "pikealsa.cmod"
if(TYPEOF(Pike_sp[0-3]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("note_off",1,"int");
#line 103 "pikealsa.cmod"
channel=Pike_sp[0-3].u.integer;
#line 103 "pikealsa.cmod"
if(TYPEOF(Pike_sp[1-3]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("note_off",2,"int");
#line 103 "pikealsa.cmod"
note=Pike_sp[1-3].u.integer;
#line 103 "pikealsa.cmod"
if(TYPEOF(Pike_sp[2-3]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("note_off",3,"int");
#line 103 "pikealsa.cmod"
velocity=Pike_sp[2-3].u.integer;
#line 103 "pikealsa.cmod"
{msg(SND_SEQ_EVENT_NOTEOFF,channel,note,velocity); pop_n_elems(args);}
	}
#define f_ALSA_note_pressure_defined
DEFAULT_CMOD_STORAGE ptrdiff_t f_ALSA_note_pressure_fun_num = 0;
DEFAULT_CMOD_STORAGE void f_ALSA_note_pressure(INT32 args) {
#line 104 "pikealsa.cmod"
INT_TYPE channel;
#line 104 "pikealsa.cmod"
INT_TYPE note;
#line 104 "pikealsa.cmod"
INT_TYPE pressure;
#line 104 "pikealsa.cmod"
if(args != 3) wrong_number_of_args_error("note_pressure",args,3);
#line 104 "pikealsa.cmod"
if(TYPEOF(Pike_sp[0-3]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("note_pressure",1,"int");
#line 104 "pikealsa.cmod"
channel=Pike_sp[0-3].u.integer;
#line 104 "pikealsa.cmod"
if(TYPEOF(Pike_sp[1-3]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("note_pressure",2,"int");
#line 104 "pikealsa.cmod"
note=Pike_sp[1-3].u.integer;
#line 104 "pikealsa.cmod"
if(TYPEOF(Pike_sp[2-3]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("note_pressure",3,"int");
#line 104 "pikealsa.cmod"
pressure=Pike_sp[2-3].u.integer;
#line 104 "pikealsa.cmod"
{msg(SND_SEQ_EVENT_KEYPRESS,channel,note,pressure); pop_n_elems(args);}
	}
#define f_ALSA_prog_chg_defined
DEFAULT_CMOD_STORAGE ptrdiff_t f_ALSA_prog_chg_fun_num = 0;
DEFAULT_CMOD_STORAGE void f_ALSA_prog_chg(INT32 args) {
#line 105 "pikealsa.cmod"
INT_TYPE channel;
#line 105 "pikealsa.cmod"
INT_TYPE patch;
#line 105 "pikealsa.cmod"
if(args != 2) wrong_number_of_args_error("prog_chg",args,2);
#line 105 "pikealsa.cmod"
if(TYPEOF(Pike_sp[0-2]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("prog_chg",1,"int");
#line 105 "pikealsa.cmod"
channel=Pike_sp[0-2].u.integer;
#line 105 "pikealsa.cmod"
if(TYPEOF(Pike_sp[1-2]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("prog_chg",2,"int");
#line 105 "pikealsa.cmod"
patch=Pike_sp[1-2].u.integer;
#line 105 "pikealsa.cmod"
{msg(SND_SEQ_EVENT_PGMCHANGE,channel,0,patch); pop_n_elems(args);} }
/*Program/Patch Change */
	#define f_ALSA_chan_pressure_defined
DEFAULT_CMOD_STORAGE ptrdiff_t f_ALSA_chan_pressure_fun_num = 0;
DEFAULT_CMOD_STORAGE void f_ALSA_chan_pressure(INT32 args) {
#line 106 "pikealsa.cmod"
INT_TYPE channel;
#line 106 "pikealsa.cmod"
INT_TYPE pressure;
#line 106 "pikealsa.cmod"
if(args != 2) wrong_number_of_args_error("chan_pressure",args,2);
#line 106 "pikealsa.cmod"
if(TYPEOF(Pike_sp[0-2]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("chan_pressure",1,"int");
#line 106 "pikealsa.cmod"
channel=Pike_sp[0-2].u.integer;
#line 106 "pikealsa.cmod"
if(TYPEOF(Pike_sp[1-2]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("chan_pressure",2,"int");
#line 106 "pikealsa.cmod"
pressure=Pike_sp[1-2].u.integer;
#line 106 "pikealsa.cmod"
{msg(SND_SEQ_EVENT_CHANPRESS,channel,0,pressure); pop_n_elems(args);}
	}
#define f_ALSA_controller_defined
DEFAULT_CMOD_STORAGE ptrdiff_t f_ALSA_controller_fun_num = 0;
DEFAULT_CMOD_STORAGE void f_ALSA_controller(INT32 args) {
#line 107 "pikealsa.cmod"
INT_TYPE channel;
#line 107 "pikealsa.cmod"
INT_TYPE param;
#line 107 "pikealsa.cmod"
INT_TYPE value;
#line 107 "pikealsa.cmod"
if(args != 3) wrong_number_of_args_error("controller",args,3);
#line 107 "pikealsa.cmod"
if(TYPEOF(Pike_sp[0-3]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("controller",1,"int");
#line 107 "pikealsa.cmod"
channel=Pike_sp[0-3].u.integer;
#line 107 "pikealsa.cmod"
if(TYPEOF(Pike_sp[1-3]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("controller",2,"int");
#line 107 "pikealsa.cmod"
param=Pike_sp[1-3].u.integer;
#line 107 "pikealsa.cmod"
if(TYPEOF(Pike_sp[2-3]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("controller",3,"int");
#line 107 "pikealsa.cmod"
value=Pike_sp[2-3].u.integer;
#line 107 "pikealsa.cmod"
{msg(SND_SEQ_EVENT_CONTROLLER,channel,param,value); pop_n_elems(args);}
	}
#define f_ALSA_pitch_bend_defined
DEFAULT_CMOD_STORAGE ptrdiff_t f_ALSA_pitch_bend_fun_num = 0;
DEFAULT_CMOD_STORAGE void f_ALSA_pitch_bend(INT32 args) {
#line 108 "pikealsa.cmod"
INT_TYPE channel;
#line 108 "pikealsa.cmod"
INT_TYPE position;
#line 108 "pikealsa.cmod"
if(args != 2) wrong_number_of_args_error("pitch_bend",args,2);
#line 108 "pikealsa.cmod"
if(TYPEOF(Pike_sp[0-2]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("pitch_bend",1,"int");
#line 108 "pikealsa.cmod"
channel=Pike_sp[0-2].u.integer;
#line 108 "pikealsa.cmod"
if(TYPEOF(Pike_sp[1-2]) != PIKE_T_INT) SIMPLE_ARG_TYPE_ERROR("pitch_bend",2,"int");
#line 108 "pikealsa.cmod"
position=Pike_sp[1-2].u.integer;
#line 108 "pikealsa.cmod"
{msg(SND_SEQ_EVENT_PITCHBEND,channel,0,position); pop_n_elems(args);} }
/*Note that position is a signed 14-bit quantity */
	#define f_ALSA_wait_defined
DEFAULT_CMOD_STORAGE ptrdiff_t f_ALSA_wait_fun_num = 0;
DEFAULT_CMOD_STORAGE void f_ALSA_wait(INT32 args) {
#line 109 "pikealsa.cmod"
if(args != 0) wrong_number_of_args_error("wait",args,0);
{
		snd_seq_sync_output_queue(THIS->seq);
		pop_n_elems(args);
	}
}

#ifdef ALSA_event_handler_defined
static void ALSA_event_handler(int ev) {
  switch(ev) {

#ifdef internal_init_ALSA_defined
  case PROG_EVENT_INIT: init_ALSA_struct(); break;

#endif /* internal_init_ALSA_defined */

#ifdef internal_exit_ALSA_defined
  case PROG_EVENT_EXIT: exit_ALSA_struct(); break;

#endif /* internal_exit_ALSA_defined */
  default: break; 
  }
}

#endif /* ALSA_event_handler_defined */
PIKE_MODULE_INIT {

#ifdef class_ALSA_defined

#ifdef PROG_ALSA_ID
#line 10 "pikealsa.cmod"
  START_NEW_PROGRAM_ID(ALSA);
#else
#line 10 "pikealsa.cmod"
  start_new_program();

#endif /* PROG_ALSA_ID */

#ifndef tObjImpl_ALSA

#undef tObjImpl_ALSA
#define tObjImpl_ALSA tObj

#endif /* tObjImpl_ALSA */

#ifdef THIS_ALSA
  ALSA_storage_offset = ADD_STORAGE(struct ALSA_struct);
#endif /* THIS_ALSA */

#ifdef ALSA_event_handler_defined
  pike_set_prog_event_callback(ALSA_event_handler);

#ifndef ALSA_gc_live_obj
  Pike_compiler->new_program->flags &= ~PROGRAM_LIVE_OBJ;

#endif /* ALSA_gc_live_obj */

#endif /* ALSA_event_handler_defined */

#ifdef f_ALSA_list_ports_defined
  f_ALSA_list_ports_fun_num =
#line 24 "pikealsa.cmod"
    ADD_FUNCTION2("list_ports", f_ALSA_list_ports, tFunc(tNone,tArr(tOr("\10\200\0\0\0\177\377\377\377",tStr))), 0, OPT_EXTERNAL_DEPEND|OPT_SIDE_EFFECT);

#endif /* f_ALSA_list_ports_defined */

#ifdef f_ALSA_set_port_defined
  f_ALSA_set_port_fun_num =
#line 52 "pikealsa.cmod"
    ADD_FUNCTION2("set_port", f_ALSA_set_port, tFunc("\10\200\0\0\0\177\377\377\377" "\10\200\0\0\0\177\377\377\377","\10\200\0\0\0\177\377\377\377"), 0, OPT_EXTERNAL_DEPEND|OPT_SIDE_EFFECT);

#endif /* f_ALSA_set_port_defined */

#ifdef f_ALSA_get_port_defined
  f_ALSA_get_port_fun_num =
#line 71 "pikealsa.cmod"
    ADD_FUNCTION2("get_port", f_ALSA_get_port, tFunc(tNone,tArr("\10\200\0\0\0\177\377\377\377")), 0, OPT_EXTERNAL_DEPEND|OPT_SIDE_EFFECT);

#endif /* f_ALSA_get_port_defined */

#ifdef f_ALSA_note_on_defined
  f_ALSA_note_on_fun_num =
#line 102 "pikealsa.cmod"
    ADD_FUNCTION2("note_on", f_ALSA_note_on, tFunc("\10\200\0\0\0\177\377\377\377" "\10\200\0\0\0\177\377\377\377" "\10\200\0\0\0\177\377\377\377",tVoid), 0, OPT_EXTERNAL_DEPEND|OPT_SIDE_EFFECT);

#endif /* f_ALSA_note_on_defined */

#ifdef f_ALSA_note_off_defined
  f_ALSA_note_off_fun_num =
#line 103 "pikealsa.cmod"
    ADD_FUNCTION2("note_off", f_ALSA_note_off, tFunc("\10\200\0\0\0\177\377\377\377" "\10\200\0\0\0\177\377\377\377" "\10\200\0\0\0\177\377\377\377",tVoid), 0, OPT_EXTERNAL_DEPEND|OPT_SIDE_EFFECT);

#endif /* f_ALSA_note_off_defined */

#ifdef f_ALSA_note_pressure_defined
  f_ALSA_note_pressure_fun_num =
#line 104 "pikealsa.cmod"
    ADD_FUNCTION2("note_pressure", f_ALSA_note_pressure, tFunc("\10\200\0\0\0\177\377\377\377" "\10\200\0\0\0\177\377\377\377" "\10\200\0\0\0\177\377\377\377",tVoid), 0, OPT_EXTERNAL_DEPEND|OPT_SIDE_EFFECT);

#endif /* f_ALSA_note_pressure_defined */

#ifdef f_ALSA_prog_chg_defined
  f_ALSA_prog_chg_fun_num =
#line 105 "pikealsa.cmod"
    ADD_FUNCTION2("prog_chg", f_ALSA_prog_chg, tFunc("\10\200\0\0\0\177\377\377\377" "\10\200\0\0\0\177\377\377\377",tVoid), 0, OPT_EXTERNAL_DEPEND|OPT_SIDE_EFFECT);

#endif /* f_ALSA_prog_chg_defined */

#ifdef f_ALSA_chan_pressure_defined
  f_ALSA_chan_pressure_fun_num =
#line 106 "pikealsa.cmod"
    ADD_FUNCTION2("chan_pressure", f_ALSA_chan_pressure, tFunc("\10\200\0\0\0\177\377\377\377" "\10\200\0\0\0\177\377\377\377",tVoid), 0, OPT_EXTERNAL_DEPEND|OPT_SIDE_EFFECT);

#endif /* f_ALSA_chan_pressure_defined */

#ifdef f_ALSA_controller_defined
  f_ALSA_controller_fun_num =
#line 107 "pikealsa.cmod"
    ADD_FUNCTION2("controller", f_ALSA_controller, tFunc("\10\200\0\0\0\177\377\377\377" "\10\200\0\0\0\177\377\377\377" "\10\200\0\0\0\177\377\377\377",tVoid), 0, OPT_EXTERNAL_DEPEND|OPT_SIDE_EFFECT);

#endif /* f_ALSA_controller_defined */

#ifdef f_ALSA_pitch_bend_defined
  f_ALSA_pitch_bend_fun_num =
#line 108 "pikealsa.cmod"
    ADD_FUNCTION2("pitch_bend", f_ALSA_pitch_bend, tFunc("\10\200\0\0\0\177\377\377\377" "\10\200\0\0\0\177\377\377\377",tVoid), 0, OPT_EXTERNAL_DEPEND|OPT_SIDE_EFFECT);

#endif /* f_ALSA_pitch_bend_defined */

#ifdef f_ALSA_wait_defined
  f_ALSA_wait_fun_num =
#line 109 "pikealsa.cmod"
    ADD_FUNCTION2("wait", f_ALSA_wait, tFunc(tNone,tVoid), 0, OPT_EXTERNAL_DEPEND|OPT_SIDE_EFFECT);

#endif /* f_ALSA_wait_defined */
#line 10 "pikealsa.cmod"
  ALSA_program=end_program();
#line 10 "pikealsa.cmod"
  ALSA_program_fun_num=add_program_constant("ALSA",ALSA_program,0);

#endif /* class_ALSA_defined */
}
PIKE_MODULE_EXIT {

#ifdef class_ALSA_defined
  if(ALSA_program) {
#line 10 "pikealsa.cmod"
    free_program(ALSA_program);
    ALSA_program=0;
  }

#endif /* class_ALSA_defined */
}
